<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Neon Courier — Mobile Endless v4 (Full)</title>
  <style>
    html, body { height: 100%; margin: 0; background:#050714; color:#e8f0ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    body { overflow: hidden; }
    .wrap { height: 100%; display:flex; align-items:center; justify-content:center; padding: 10px; box-sizing: border-box; }
    canvas{
      border: 1px solid rgba(120,160,255,.25);
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,.55);
      background:#060812;
      touch-action: none;
      display:block;
    }
    .ui{
      position: fixed; left: 12px; right: 12px; top: 10px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      pointer-events: none;
      z-index: 10;
    }
    .pill{
      pointer-events: auto;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 999px;
      padding: 8px 10px;
      font-size: 12px;
      backdrop-filter: blur(6px);
      user-select: none;
      -webkit-user-select: none;
    }
    .row{ display:flex; gap:10px; align-items:center; }
    input[type="range"]{ width: 130px; }
    .help{
      position: fixed; left: 12px; right: 12px; bottom: 10px;
      font-size: 12px; opacity: .82;
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div class="ui">
    <div class="row">
      <div class="pill" id="btnStart">Start</div>
      <div class="pill" id="btnPause">Pause</div>
      <div class="pill" id="btnMute">Mute</div>
    </div>
    <div class="pill row">
      <span>Vol</span>
      <input id="vol" type="range" min="0" max="1" step="0.01" value="0.45">
    </div>
  </div>

  <div class="wrap"><canvas id="c"></canvas></div>
  <div class="help">Mobile: drag kiri = joystick • tombol DASH kanan-bawah • Tap PAUSE kanan-atas • PC: WASD/Arrow + Space</div>

<script>
(() => {
  // Virtual resolution (world units)
  const W = 900, H = 520;

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: true });

  // Helpers
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const rand  = (a,b) => a + Math.random()*(b-a);
  const chance = (p) => Math.random() < p;

  function aabb(a, b){
    return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
  }

  // DPR-aware responsive canvas
  let dpr = 1;
  let scale = 1;

  function resize(){
    dpr = Math.max(1, window.devicePixelRatio || 1);

    const vw = window.innerWidth;
    const vh = window.innerHeight;
    const pad = 20;

    scale = Math.min((vw - pad) / W, (vh - pad) / H);
    scale = clamp(scale, 0.55, 1.8);

    const cssW = Math.floor(W * scale);
    const cssH = Math.floor(H * scale);

    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";

    canvas.width  = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
  }
  window.addEventListener("resize", resize);
  resize();

  // Storage (High Score + Top 5)
  const HS_KEY = "neonCourier_HS_v4";
  const LB_KEY = "neonCourier_LB_v4";

  function loadHS(){
    try { return Number(localStorage.getItem(HS_KEY) || 0); } catch { return 0; }
  }
  function saveHS(v){
    try { localStorage.setItem(HS_KEY, String(v)); } catch {}
  }
  function loadLB(){
    try {
      const raw = localStorage.getItem(LB_KEY);
      const arr = raw ? JSON.parse(raw) : [];
      return Array.isArray(arr) ? arr.filter(n => typeof n === "number") : [];
    } catch { return []; }
  }
  function saveLB(arr){
    try { localStorage.setItem(LB_KEY, JSON.stringify(arr)); } catch {}
  }
  function pushScoreToLB(s){
    const lb = loadLB();
    lb.push(s);
    lb.sort((a,b)=>b-a);
    const top = lb.slice(0,5);
    saveLB(top);
    return top;
  }

  // Audio (simple)
  let audioCtx = null;
  let master = null;
  let music = null;
  let muted = false;

  const volEl = document.getElementById("vol");

  function ensureAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      master = audioCtx.createGain();
      master.gain.value = Number(volEl.value);
      master.connect(audioCtx.destination);
    }
  }

  volEl.addEventListener("input", () => {
    if (master) master.gain.value = Number(volEl.value);
  });

  function beep(freq=440, dur=0.08, type="sine", gain=0.05){
    if (muted) return;
    ensureAudio();
    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t);
    g.gain.setValueAtTime(gain, t);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    osc.connect(g);
    g.connect(master);
    osc.start(t);
    osc.stop(t + dur);
  }

  function startMusic(){
    if (muted) return;
    ensureAudio();
    if (music) return;

    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    osc.type = "triangle";

    const g = audioCtx.createGain();
    g.gain.value = 0;

    const interval = 12;
    for (let i=0;i<120;i++){
      const tt = t + i*interval;
      osc.frequency.setValueAtTime(110, tt);
      osc.frequency.linearRampToValueAtTime(165, tt + 6);
      osc.frequency.linearRampToValueAtTime(110, tt + 12);

      g.gain.setValueAtTime(0.00, tt);
      g.gain.linearRampToValueAtTime(0.020, tt + 0.35);
      g.gain.linearRampToValueAtTime(0.010, tt + 2.1);
      g.gain.linearRampToValueAtTime(0.00, tt + 12);
    }

    osc.connect(g);
    g.connect(master);
    osc.start(t);

    music = { osc, g };
  }

  function stopMusic(){
    if (!music) return;
    try { music.osc.stop(); } catch {}
    music = null;
  }

  // Input
  const keys = {};
  let dashPressed = false;

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys[k] = true;

    if (e.key === "Enter") { if (state !== "playing") startGame(); }
    if (k === "p") togglePause();
    if (k === "m") toggleMute();
    if (k === " " || k === "spacebar") dashPressed = true;

    ensureAudio(); audioCtx.resume?.();
  });
  window.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);

  function toggleMute(){
    muted = !muted;
    if (muted) stopMusic();
    else if (state === "playing") startMusic();
  }

  // Pointer -> world coords
  function pointerToWorld(ev){
    const r = canvas.getBoundingClientRect();
    const x = (ev.clientX - r.left) * (W / r.width);
    const y = (ev.clientY - r.top)  * (H / r.height);
    return {x, y};
  }

  // Virtual controls
  const joy = { active:false, id:null, ox:0, oy:0, vx:0, vy:0 };
  const btnDash  = { x: W-175, y: H-120, w: 130, h: 78 };
  const btnPause = { x: W-160, y: 18,    w: 130, h: 42 };

  canvas.addEventListener("pointerdown", (ev) => {
    ensureAudio(); audioCtx?.resume?.();
    const p = pointerToWorld(ev);

    // Pause button hitbox
    if (p.x >= btnPause.x && p.x <= btnPause.x + btnPause.w && p.y >= btnPause.y && p.y <= btnPause.y + btnPause.h){
      togglePause();
      return;
    }

    // Dash button hitbox
    if (p.x >= btnDash.x && p.x <= btnDash.x + btnDash.w && p.y >= btnDash.y && p.y <= btnDash.y + btnDash.h){
      dashPressed = true;
      return;
    }

    // Joystick area (left side)
    if (p.x < W * 0.55){
      joy.active = true;
      joy.id = ev.pointerId;
      joy.ox = p.x; joy.oy = p.y;
      joy.vx = 0; joy.vy = 0;
      canvas.setPointerCapture?.(ev.pointerId);
    }
  });

  canvas.addEventListener("pointermove", (ev) => {
    if (!joy.active || joy.id !== ev.pointerId) return;
    const p = pointerToWorld(ev);
    const dx = p.x - joy.ox;
    const dy = p.y - joy.oy;
    const max = 95;
    joy.vx = clamp(dx / max, -1, 1);
    joy.vy = clamp(dy / max, -1, 1);
  });

  function endJoy(ev){
    if (joy.active && joy.id === ev.pointerId){
      joy.active = false;
      joy.id = null;
      joy.vx = 0; joy.vy = 0;
    }
  }
  canvas.addEventListener("pointerup", endJoy);
  canvas.addEventListener("pointercancel", endJoy);

  // UI buttons
  document.getElementById("btnStart").addEventListener("click", () => { if (state !== "playing") startGame(); });
  document.getElementById("btnPause").addEventListener("click", () => togglePause());
  document.getElementById("btnMute").addEventListener("click", () => toggleMute());

  // Game content
  const biomes = [
    { name:"CYAN GRID",    bg1:"#0a1230", bg2:"#04060e", grid:"#6aa2ff", droneA:"#4dfcff", droneB:"#ff4fd8", core:"#4dfcff", accent:"#4dfcff" },
    { name:"MAGENTA DUSK", bg1:"#2a0a2a", bg2:"#07040d", grid:"#ff7bd1", droneA:"#ff7bd1", droneB:"#ffd84d", core:"#ffd84d", accent:"#ff7bd1" },
    { name:"LIME HAZE",    bg1:"#0a2a1a", bg2:"#040a07", grid:"#a6ff4d", droneA:"#a6ff4d", droneB:"#4dfcff", core:"#a6ff4d", accent:"#a6ff4d" },
    { name:"VIOLET RIFT",  bg1:"#1b103a", bg2:"#05040b", grid:"#b28cff", droneA:"#b28cff", droneB:"#4dfcff", core:"#ff7bd1", accent:"#b28cff" },
  ];

  let state = "menu"; // menu | playing | paused | gameover
  let tPrev = performance.now();

  const player = {
    x: 140, y: 240, w: 22, h: 22,
    speed: 340,
    lives: 3,
    inv: 0,
    shield: 0,
    dashCd: 0,
    dashTime: 0,
    dashDirX: 1, dashDirY: 0
  };

  const drones = [];
  const cores = [];
  const powers = [];
  const particles = [];

  let score = 0;
  let best = loadHS();
  let difficulty = 1;

  let spawnDroneTimer = 0.4;
  let spawnCoreTimer = 0.8;
  let spawnPowerTimer = 6;
  let shake = 0;

  let slowMo = 0;
  let magnet = 0;

  let biomeIndex = 0;
  let biomeTime = 0;
  const BIOME_PERIOD = 45;
  let flash = 0;

  let quest = null;
  let questCooldown = 2.5;

  function reset(){
    player.x = 140; player.y = H/2;
    player.lives = 3; player.inv = 0; player.shield = 0;
    player.dashCd = 0; player.dashTime = 0;

    drones.length = 0;
    cores.length = 0;
    powers.length = 0;
    particles.length = 0;

    score = 0;
    difficulty = 1;

    spawnDroneTimer = 0.4;
    spawnCoreTimer = 0.8;
    spawnPowerTimer = 6;

    slowMo = 0;
    magnet = 0;

    shake = 0;
    biomeIndex = 0;
    biomeTime = 0;
    flash = 0;

    quest = null;
    questCooldown = 2.5;
  }

  function startGame(){
    reset();
    state = "playing";
    startMusic();
    beep(660, 0.07, "triangle", 0.06);
    beep(880, 0.07, "triangle", 0.05);
  }

  function togglePause(){
    if (state === "playing") state = "paused";
    else if (state === "paused") state = "playing";
  }

  function addScore(v){
    score += v;
    const s = Math.floor(score);
    if (s > best){
      best = s;
      saveHS(best);
    }
  }

  function spawnParticles(x,y,col,n=10,spd=180){
    for (let i=0;i<n;i++){
      const a = rand(0, Math.PI*2);
      const r = rand(0.6, 1.0);
      particles.push({ x,y, vx:Math.cos(a)*spd*r, vy:Math.sin(a)*spd*r, life:rand(0.25,0.55), col });
    }
  }

  function hitPlayer(){
    if (player.inv > 0) return;

    if (player.shield > 0){
      player.shield -= 1;
      player.inv = 0.55;
      shake = 8;
      spawnParticles(player.x+player.w/2, player.y+player.h/2, "#4dfcff", 14, 220);
      beep(520, 0.06, "square", 0.05);
      return;
    }

    player.lives -= 1;
    player.inv = 1.0;
    shake = 12;
    spawnParticles(player.x+player.w/2, player.y+player.h/2, "#ff4f72", 18, 260);
    beep(220, 0.10, "sawtooth", 0.05);

    if (quest && quest.type === "nofail") questFailed();
    if (player.lives <= 0) gameOver();
  }

  function gameOver(){
    state = "gameover";
    stopMusic();
    const s = Math.floor(score);
    best = Math.max(best, s);
    saveHS(best);
    pushScoreToLB(s);
  }

  function spawnDrone(kind){
    const b = biomes[biomeIndex];
    const h = rand(18, 58);
    const w = rand(34, kind === "burst" ? 130 : 100);
    const y = rand(60, H - 60 - h);
    const base = rand(190, 280) * (1 + difficulty*0.10);
    const vx = -(base * (kind === "burst" ? 1.25 : 1.0));
    drones.push({ kind, x: W + 60, y, w, h, vx, t: rand(0,10), amp: rand(10,55), color: chance(0.5) ? b.droneA : b.droneB });
  }

  function spawnCore(){
    const b = biomes[biomeIndex];
    const s = rand(14, 20);
    cores.push({ x: rand(W*0.35, W-80), y: rand(70, H-70), w:s, h:s, pulse: rand(0, Math.PI*2), col: b.core });
  }

  function spawnPower(){
    const types = ["shield","slow","magnet"];
    const type = types[Math.floor(Math.random()*types.length)];
    const s = 18;
    powers.push({ type, x: rand(W*0.40, W-80), y: rand(70, H-70), w:s, h:s, pulse: rand(0, Math.PI*2) });
  }

  function newQuest(){
    const pool = [
      { type:"collect", goal:3,  desc:"Ambil 3 data-core" },
      { type:"survive", goal:20, desc:"Bertahan 20 detik" },
      { type:"power",   goal:1,  desc:"Ambil 1 power-up" },
      { type:"nofail",  goal:18, desc:"18 detik tanpa kena" }
    ];
    const q = pool[Math.floor(Math.random()*pool.length)];
    quest = { type:q.type, goal:q.goal, progress:0, timer:0, desc:q.desc };
  }

  function questComplete(){
    if (!quest) return;
    const bonus = 200 + Math.floor(difficulty*25);
    addScore(bonus);
    flash = 0.25;
    spawnParticles(W/2, H/2, biomes[biomeIndex].accent, 36, 320);
    beep(1200, 0.06, "triangle", 0.05);
    quest = null;
    questCooldown = 3.0;
  }

  function questFailed(){
    flash = 0.18;
    beep(260, 0.08, "sawtooth", 0.04);
    quest = null;
    questCooldown = 3.5;
  }

  function update(dt){
    if (state !== "playing") return;

    player.inv = Math.max(0, player.inv - dt);
    player.dashCd = Math.max(0, player.dashCd - dt);
    player.dashTime = Math.max(0, player.dashTime - dt);
    slowMo = Math.max(0, slowMo - dt);
    magnet = Math.max(0, magnet - dt);
    shake = Math.max(0, shake - dt*18);
    flash = Math.max(0, flash - dt);

    addScore(dt * 12);
    difficulty = 1 + score / 240;

    biomeTime += dt;
    if (biomeTime >= BIOME_PERIOD){
      biomeTime = 0;
      biomeIndex = (biomeIndex + 1) % biomes.length;
      spawnParticles(W/2, 80, biomes[biomeIndex].accent, 26, 260);
      beep(520, 0.05, "sine", 0.05);
    }

    if (!quest){
      questCooldown = Math.max(0, questCooldown - dt);
      if (questCooldown <= 0) newQuest();
    } else {
      quest.timer += dt;
      if (quest.type === "survive" || quest.type === "nofail"){
        quest.progress = quest.timer;
        if (quest.progress >= quest.goal) questComplete();
      }
    }

    let ax = 0, ay = 0;
    if (keys["arrowleft"] || keys["a"]) ax -= 1;
    if (keys["arrowright"]|| keys["d"]) ax += 1;
    if (keys["arrowup"]   || keys["w"]) ay -= 1;
    if (keys["arrowdown"] || keys["s"]) ay += 1;

    // joystick
    ax += joy.vx; ay += joy.vy;

    const len = Math.hypot(ax, ay);
    if (len > 0.001){ ax /= len; ay /= len; }

    // dash
    if ((dashPressed || keys[" "]) && player.dashCd <= 0 && player.dashTime <= 0){
      const dx = (Math.abs(ax)+Math.abs(ay)) > 0.01 ? ax : 1;
      const dy = (Math.abs(ax)+Math.abs(ay)) > 0.01 ? ay : 0;
      player.dashDirX = dx; player.dashDirY = dy;
      player.dashTime = 0.14;
      player.dashCd = 0.70;
      player.inv = Math.max(player.inv, 0.20);
      beep(980, 0.05, "triangle", 0.05);
    }
    dashPressed = false;

    let sp = player.speed;
    if (player.dashTime > 0){ sp = 880; ax = player.dashDirX; ay = player.dashDirY; }

    player.x += ax * sp * dt;
    player.y += ay * sp * dt;

    player.x = clamp(player.x, 40, W - 40 - player.w);
    player.y = clamp(player.y, 50, H - 50 - player.h);

    // spawns
    spawnDroneTimer -= dt;
    spawnCoreTimer  -= dt;
    spawnPowerTimer -= dt;

    const droneInterval = clamp(0.98 - difficulty*0.058, 0.26, 0.98);
    const coreInterval  = clamp(1.08 - difficulty*0.035, 0.42, 1.08);
    const patternMix = biomeIndex % 2 === 0 ? ["lane","lane","zig","burst"] : ["lane","zig","zig","burst"];

    if (spawnDroneTimer <= 0){
      const kind = patternMix[Math.floor(Math.random()*patternMix.length)];
      spawnDrone(kind);
      if (chance(clamp(0.08 + difficulty*0.035, 0.08, 0.60))) spawnDrone(chance(0.5) ? "lane" : kind);
      spawnDroneTimer = droneInterval * rand(0.72, 1.15);
    }

    if (spawnCoreTimer <= 0 && cores.length < 3){
      spawnCore();
      spawnCoreTimer = coreInterval * rand(0.80, 1.25);
    }

    if (spawnPowerTimer <= 0 && powers.length < 1){
      spawnPower();
      spawnPowerTimer = clamp(8.2 - difficulty*0.2, 4.6, 8.2);
    }

    const enemyMul = slowMo > 0 ? 0.55 : 1.0;

    // drones
    for (let i = drones.length-1; i >= 0; i--){
      const d = drones[i];
      d.t += dt;
      d.x += d.vx * dt * enemyMul;

      if (d.kind === "zig"){
        d.y += Math.sin(d.t*5.2) * (d.amp * dt);
        d.y = clamp(d.y, 50, H - 50 - d.h);
      }

      if (d.x + d.w < -90) drones.splice(i, 1);
      else if (aabb(player, d)) hitPlayer();
    }

    // cores
    for (let i = cores.length-1; i >= 0; i--){
      const c = cores[i];
      c.pulse += dt * 6;

      if (magnet > 0){
        const px = player.x + player.w/2, py = player.y + player.h/2;
        const cx = c.x + c.w/2,       cy = c.y + c.h/2;
        const dx = px - cx, dy = py - cy;
        const dist = Math.hypot(dx, dy);
        const range = 180;
        if (dist < range && dist > 0.001){
          const pull = (1 - dist/range) * 340;
          c.x += (dx/dist) * pull * dt;
          c.y += (dy/dist) * pull * dt;
        }
      }

      if (aabb(player, c)){
        cores.splice(i, 1);
        addScore(90);
        spawnParticles(c.x+c.w/2, c.y+c.h/2, c.col, 14, 220);
        beep(880, 0.06, "sine", 0.06);

        if (quest && quest.type === "collect"){
          quest.progress += 1;
          if (quest.progress >= quest.goal) questComplete();
        }
      }
    }

    // power-ups
    for (let i = powers.length-1; i >= 0; i--){
      const p = powers[i];
      p.pulse += dt * 6;

      if (aabb(player, p)){
        powers.splice(i, 1);

        if (p.type === "shield"){
          player.shield += 1;
          spawnParticles(player.x+player.w/2, player.y+player.h/2, "#4dfcff", 14, 220);
          beep(600, 0.06, "square", 0.05);
        } else if (p.type === "slow"){
          slowMo = 4.3;
          spawnParticles(player.x+player.w/2, player.y+player.h/2, "#b28cff", 14, 210);
          beep(300, 0.06, "triangle", 0.05);
        } else if (p.type === "magnet"){
          magnet = 6.0;
          spawnParticles(player.x+player.w/2, player.y+player.h/2, "#ff7bd1", 14, 210);
          beep(740, 0.06, "sine", 0.05);
        }

        addScore(45);

        if (quest && quest.type === "power"){
          quest.progress += 1;
          if (quest.progress >= quest.goal) questComplete();
        }
      }
    }

    // particles
    for (let i = particles.length-1; i >= 0; i--){
      const p = particles[i];
      p.life -= dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - dt*2.2);
      p.vy *= (1 - dt*2.2);
      if (p.life <= 0) particles.splice(i, 1);
    }
  }

  function drawBackground(){
    const b = biomes[biomeIndex];
    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, b.bg1);
    g.addColorStop(1, b.bg2);
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    ctx.globalAlpha = 0.14;
    ctx.strokeStyle = b.grid;
    for (let x=40; x<W; x+=40){ ctx.beginPath(); ctx.moveTo(x,40); ctx.lineTo(x,H-40); ctx.stroke(); }
    for (let y=40; y<H; y+=40){ ctx.beginPath(); ctx.moveTo(40,y); ctx.lineTo(W-40,y); ctx.stroke(); }
    ctx.globalAlpha = 1;

    ctx.strokeStyle = "rgba(255,255,255,.12)";
    ctx.lineWidth = 2;
    ctx.strokeRect(40, 40, W-80, H-80);

    const prog = biomeTime / BIOME_PERIOD;
    ctx.fillStyle = "rgba(255,255,255,.08)";
    ctx.fillRect(40, 44, W-80, 6);
    ctx.fillStyle = b.accent;
    ctx.globalAlpha = 0.55;
    ctx.fillRect(40, 44, (W-80)*prog, 6);
    ctx.globalAlpha = 1;
  }

  function drawButton(x,y,w,h,label){
    ctx.fillStyle = "rgba(255,255,255,.10)";
    ctx.fillRect(x,y,w,h);
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.strokeRect(x,y,w,h);
    ctx.fillStyle = "rgba(232,240,255,.92)";
    ctx.font = "700 16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(label, x + 14, y + 27);
  }

  function draw(){
    // Draw in world coords; transform into device pixels
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.setTransform(dpr*scale, 0, 0, dpr*scale, 0, 0);

    ctx.save();
    if (shake > 0) ctx.translate(rand(-shake, shake), rand(-shake, shake));

    drawBackground();
    const b = biomes[biomeIndex];

    // glow
    ctx.save();
    ctx.globalCompositeOperation = "lighter";

    for (const c of cores){
      const pulse = 0.5 + 0.5*Math.sin(c.pulse);
      ctx.globalAlpha = 0.15 + 0.25*pulse;
      ctx.fillStyle = c.col;
      ctx.beginPath(); ctx.arc(c.x+c.w/2, c.y+c.h/2, 18, 0, Math.PI*2); ctx.fill();
    }

    for (const p of powers){
      const pulse = 0.5 + 0.5*Math.sin(p.pulse);
      let col = "#ffe14d";
      if (p.type === "shield") col = "#4dfcff";
      if (p.type === "slow") col = "#b28cff";
      if (p.type === "magnet") col = "#ff7bd1";
      ctx.globalAlpha = 0.12 + 0.22*pulse;
      ctx.fillStyle = col;
      ctx.beginPath(); ctx.arc(p.x+p.w/2, p.y+p.h/2, 22, 0, Math.PI*2); ctx.fill();
    }

    for (const d of drones){
      ctx.globalAlpha = 0.10;
      ctx.fillStyle = d.color;
      ctx.fillRect(d.x-4, d.y-4, d.w+8, d.h+8);
    }

    const blink = player.inv > 0 ? (Math.floor(performance.now()/70) % 2 === 0) : true;
    if (blink){
      ctx.globalAlpha = 0.20;
      ctx.fillStyle = player.shield > 0 ? "#4dfcff" : "#a6ff4d";
      ctx.beginPath(); ctx.arc(player.x+player.w/2, player.y+player.h/2, player.shield>0 ? 30 : 24, 0, Math.PI*2); ctx.fill();
    }

    for (const p of particles){
      ctx.globalAlpha = clamp(p.life, 0, 0.5);
      ctx.fillStyle = p.col;
      ctx.fillRect(p.x-2, p.y-2, 4, 4);
    }

    ctx.restore();
    ctx.globalAlpha = 1;
    ctx.globalCompositeOperation = "source-over";

    // solids
    for (const c of cores){
      ctx.fillStyle = c.col;
      ctx.fillRect(c.x, c.y, c.w, c.h);
    }

    for (const p of powers){
      let col = "#ffe14d";
      if (p.type === "shield") col = "#4dfcff";
      if (p.type === "slow") col = "#b28cff";
      if (p.type === "magnet") col = "#ff7bd1";
      ctx.fillStyle = col;
      ctx.fillRect(p.x, p.y, p.w, p.h);
    }

    for (const d of drones){
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(d.x+4, d.y+4, d.w, d.h);
      ctx.fillStyle = d.color;
      ctx.fillRect(d.x, d.y, d.w, d.h);
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.fillRect(d.x + d.w - 10, d.y + 4, 6, 6);
    }

    const blink2 = player.inv > 0 ? (Math.floor(performance.now()/70) % 2 === 0) : true;
    if (blink2){
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.fillRect(player.x+4, player.y+4, player.w, player.h);
      ctx.fillStyle = "#a6ff4d";
      ctx.fillRect(player.x, player.y, player.w, player.h);
      if (player.shield > 0){
        ctx.strokeStyle = "rgba(77,252,255,.8)";
        ctx.lineWidth = 2;
        ctx.strokeRect(player.x-3, player.y-3, player.w+6, player.h+6);
      }
    }

    // UI text
    ctx.fillStyle = "rgba(232,240,255,.92)";
    ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText(`Score: ${Math.floor(score)}   Best: ${best}   Lives: ${player.lives}   Shield: ${player.shield}`, 56, 30);
    ctx.fillText(`Biome: ${b.name}`, 56, 52);

    if (quest){
      let progTxt = "";
      if (quest.type === "collect" || quest.type === "power") progTxt = `${quest.progress}/${quest.goal}`;
      else progTxt = `${quest.progress.toFixed(1)}/${quest.goal}s`;

      ctx.fillStyle = "rgba(255,255,255,.10)";
      ctx.fillRect(56, 64, 520, 32);
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.strokeRect(56, 64, 520, 32);
      ctx.fillStyle = b.accent;
      ctx.fillText(`Quest: ${quest.desc} (${progTxt})`, 70, 86);
    }

    // on-screen buttons
    drawButton(btnPause.x, btnPause.y, btnPause.w, btnPause.h, state === "paused" ? "RESUME" : "PAUSE");
    drawButton(btnDash.x, btnDash.y, btnDash.w, btnDash.h, "DASH");

    // joystick visual
    if (joy.active){
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "#e8f0ff";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(joy.ox, joy.oy, 24, 0, Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(joy.ox, joy.oy); ctx.lineTo(joy.ox + joy.vx*95, joy.oy + joy.vy*95); ctx.stroke();
      ctx.globalAlpha = 1;
    }

    if (flash > 0){
      ctx.globalAlpha = flash;
      ctx.fillStyle = b.accent;
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
    }

    // overlays
    ctx.textAlign = "center";

    if (state === "menu"){
      ctx.fillStyle = "rgba(232,240,255,.95)";
      ctx.font = "900 34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("NEON COURIER — ENDLESS v4", W/2, H/2 - 26);

      ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Klik Start untuk mulai. Mobile: drag kiri untuk gerak, tombol DASH kanan-bawah.", W/2, H/2 + 8);
      ctx.fillText("Tip: skor naik terus, biome & quest berganti otomatis.", W/2, H/2 + 32);
    }

    if (state === "paused"){
      ctx.fillStyle = "rgba(0,0,0,.45)";
      ctx.fillRect(40, 40, W-80, H-80);
      ctx.fillStyle = "rgba(232,240,255,.95)";
      ctx.font = "900 34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("PAUSED", W/2, H/2 - 10);
      ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("Tap PAUSE lagi untuk lanjut.", W/2, H/2 + 22);
    }

    if (state === "gameover"){
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.fillRect(40, 40, W-80, H-80);

      ctx.fillStyle = "rgba(255,80,120,.95)";
      ctx.font = "900 34px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText("GAME OVER", W/2, H/2 - 34);

      ctx.fillStyle = "rgba(232,240,255,.95)";
      ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.fillText(`Score: ${Math.floor(score)}   Best: ${best}`, W/2, H/2 - 4);

      const lb = loadLB();
      if (lb.length){
        ctx.globalAlpha = 0.9;
        ctx.fillText("Top 5 (local): " + lb.slice(0,5).join(" • "), W/2, H/2 + 22);
        ctx.globalAlpha = 1;
      }

      ctx.fillText("Klik Start untuk main lagi.", W/2, H/2 + 46);
    }

    ctx.textAlign = "start";

    ctx.restore();
  }

  function loop(now){
    const dt = Math.min(0.033, (now - tPrev) / 1000);
    tPrev = now;

    if (state !== "paused") update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
